<!doctype html>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
<link rel="stylesheet" type="text/css" href="../../styles/commonstyles.css" />
<link rel="stylesheet" href="../../styles/blogstyle.css" />
<link rel="stylesheet" href="../../styles/iconbarstyle.css" />
<link rel="stylesheet" href="../../styles/toc.css" />
<link rel="stylesheet" href="../../styles/figcaptionstyles.css" />

<html lang="en-us">
  <head>
    <title>Databases</title>
  </head>

  <body>
    <div class="icon-bar">
      <a class="active" href="../../index.html"><i class="fa fa-home"></i></a>
    </div>

    <div style="padding: 20px">
      <p>02 May 2025</p>
      <p>
        <a href="../06_ml/06.html" style="color: firebrick"> &#8617; Previous</a>
      </p>

      <hr />

      <div id="toc"></div>
      <script src="../../scripts/toc.js"></script>
    </div>
    <h2>Feature scaling</h2>
    <p>Consider below model for housing price</p>
    <ul>
      <li>price = w<sub>(1)</sub> x<sub>(1)</sub> + w<sub>(2)</sub> x<sub>(2)</sub> + b</li>
      <li>x<sub>(1)</sub> - size in sq feet (range: 300-2000). Range is large.</li>
      <li>x<sub>(2)</sub> - bedrooms (range:0-5). Range is small.</li>
    </ul>
    <p>
      Applying the largest feature range (2000 and 5) into the model, with model parameters w<sub>(1)</sub> = 50 ,
      w<sub>(2)</sub>= 0.1 , b = 50 :
    </p>

    <ul>
      <li>price = w<sub>(1)</sub> x <sub>(1)</sub> + w<sub>(2)</sub> x <sub>(2)</sub> + b</li>
      <li>
        price = 50 * 2000 + 0.1 * 5 + 50 = $100,050.5. This is far from actual price of 500k dollars. So this is not a
        good parameter choice
      </li>
    </ul>

    <p>Another example with w<sub>(1)</sub> = 0.1 , w<sub>(2)</sub>= 50 , b = 50 :</p>

    <ul>
      <li>price = w<sub>(1)</sub> x <sub>(1)</sub> + w<sub>(2)</sub> x <sub>(2)</sub> + b</li>
      <li>price = 0.1 * 2000 + 0.1 * 5 + 50 = $500,000. This is more reasonable</li>
    </ul>

    <p>
      When the possible range of values of a feature is large a good model will learn to choose a relatively small
      parameter value, like 0.1. Likewise, when the possible values of the feature are small then a reasonable parameter
      value will be relatively large like 50.
    </p>
    <figure>
      <img src="feature_parameter_size.png" alt="" width="600" height="350" />
      <figcaption>Feature and parameter size (credit Andrew NG).</figcaption>
    </figure>
    <p>
      The contour plot has the horizontal axis has a much narrower range, say between zero and one, whereas the vertical
      axis takes on much larger values, say between 10 and 100. So the contours form ovals or ellipses. This is because
      a very small change to w1 can have a very large impact on the estimated price and that's a very large impact on
      the cost J.
    </p>

    <p>
      Because the contours are so tall and skinny, gradient descent may end up bouncing back and forth for a long time
      before it can finally find its way to the global minimum. In situations like this, a useful thing to do is to
      scale the features.This means performing some transformation of your training data so that x <sub>1</sub> say
      might now range from 0 to 1 and x<sub>2</sub> might also range from 0 to 1.
    </p>
    <figure>
      <img src="scatterplot_rescaled.png" alt="" width="400" height="400" />
      <figcaption>Scatterplot rescaled (credit Andrew NG).</figcaption>
    </figure>
    <p>
      When you have different features that take on very different ranges of values, it can cause gradient descent to
      run slowly but re scaling the different features so they all take on comparable range of values. After rescaling,
      gradient descent can find a much more direct path to the global minimum.
    </p>
    <p>
      The key point is that the re-scaled x <sub>1</sub> and x <sub>2</sub> are both now taking comparable ranges of
      values to each other. If you run gradient descent on a cost function, contours will look more like this more like
      circles and less tall and skinny.
    </p>

    <figure>
      <img src="contour_after_scaling.png" alt="" width="600" height="300" />
      <figcaption>After scaled (credit Andrew NG).</figcaption>
    </figure>

    <p>One of the option to scale is dividing by the maximum</p>
    <figure>
      <img src="scaling_dividing_my_max.png" alt="" width="550" height="310" />
      <figcaption>Dividing by maximum (credit Andrew NG).</figcaption>
    </figure>
    <p>The other option to scale is mean normalization</p>
    <figure>
      <img src="scaling_mean_normalisation.png" alt="" width="550" height="310" />
      <figcaption>Mean normalisation (credit Andrew NG).</figcaption>
    </figure>
    <p>Yet other option to scale is z-score normalization</p>
    <figure>
      <img src="z_score_normalisation.png" alt="" width="550" height="280" />
      <figcaption>Z-Score normalisation (credit Andrew NG).</figcaption>
    </figure>
    <p>There's almost never any harm to carrying out feature re-scaling. When in doubt, you to just carry it out</p>

    <p>
      Following is an example of cases where feature scaling can be applied.In this example, x<sub>5</sub> representing
      temperature values are around 100, which is actually pretty large compared to other scale features, and this will
      actually cause gradient descent to run more slowly. In this case, feature re-scaling will help.
    </p>
    <figure>
      <img src="feature_scaling_numbers.png" alt="" width="420" height="280" />
      <figcaption>Scaling (credit Andrew NG).</figcaption>
    </figure>
    <hr />
    <p>
      <a href="../06_ml/06.html" style="color: firebrick"> &#8617; Previous</a>
    </p>
  </body>
</html>