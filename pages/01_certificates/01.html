<!doctype html>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
<link rel="stylesheet" type="text/css" href="../../styles/commonstyles.css" />
<link rel="stylesheet" href="../../styles/blogstyle.css" />
<link rel="stylesheet" href="../../styles/iconbarstyle.css" />
<link rel="stylesheet" href="../../styles/toc.css" />

<html lang="en-us">
  <head>
    <title>Digital Certificates</title>
  </head>

  <body>
    <div class="icon-bar">
      <a class="active" href="../../index.html"><i class="fa fa-home"></i></a>
    </div>

    <div style="padding: 20px">
      <h1>Digital Certificates</h1>

      <p>16 March 2025</p>
      <hr />

      <div id="toc"></div>
      <script src="../../scripts/toc.js"></script>

      <p>
        Digital Certificates are one of the foundation blocks of security in digital world. They are used to
        authenticate the identity of the device and secure the transactions between devices. Digital certificate is a
        data structure that contains various parameters that can be used to establish trust. This section provides an
        overview of the digital certificates.
      </p>
      <p>Let us dive into few concepts:</p>

      <h2>Symmetric key cryptography</h2>
      <p>In Symmetric key cryptography same key is used to encrypt and decrypt.</p>
      <ul>
        <li>Advantage: They are faster to encrypt and decrypt</li>
        <li>Disadvantage: The secret key has to be shared between the sender and receiver.</li>
      </ul>

      <p>
        Secure key distribution is a major problem to be solved, and this is where the Asymmetric key cryptography
        excells
      </p>

      <h2>Asymmetric key cryptography (public key cryptography)</h2>

      <p>
        Asymmetric key cryptography solves the above mentioned key distribution problem by using 2 keys (key pair)
        instead of a single shared key.
      </p>
      <ul>
        <li>One of the keys is kept secret - private key</li>
        <li>Other key is made public - public key</li>
      </ul>

      <p>
        There are different algorithm choices available for asymmetric key cryptography. Some of the popular ones are:
      </p>
      <ul>
        <li>
          RSA - Rivest–Shamir–Adleman.
          <ul>
            <li>Most suited for communication encryption</li>
            <li>Based on difficulty of Prime factorization</li>
          </ul>
        </li>

        <li>
          DSA - Digital Signature Algorithm
          <ul>
            <li>Most suited for signing (encrypting hash) and verification</li>
            <li>Based on difficulty of discrete logarithm</li>
          </ul>
        </li>

        <li>
          ECC- Elliptic Curve Cryptography
          <ul>
            <li>Greater cryptographic strengh for equivalent key size in RSA/DSA</li>
          </ul>
        </li>
      </ul>

      <p>
        Some algorithms like RSA technically allows YOU to choose which key is private and which is public. But some
        others like ECC does not give you a choice as they are dissimilar in computation.
      </p>
      <p></p>

      <h2>Hybrid approach</h2>
      <p>
        The Asymetric encryption is computationally heavy (could be 1000s of times heavy) as compared to the symmetric
        encryption. In practical usecases a hybrid approach is used where public key cryptography is used for securely
        sharing symmetric key. After this initial step, the symmetric key is used always.
      </p>
      <p>Majority of the communication encryption usecases follows a hybrid approch.</p>

      <h2>Assumetric encryption - Key aspects</h2>

      <h3>Sharing</h3>
      <p></p>
      <ul>
        <li>Public keys can be shared to anyone publicly. There is no secrecy involved here.</li>
        <li>Private keys are not shared with anyone else.</li>
      </ul>

      <p>Public keys can be shared via different mechanisms . For example:</p>
      <ul>
        <li>Manually via email or similar mechanisms</li>
        <li>Using a protocol, like TLS</li>
      </ul>

      <h3>Oneway Encryption</h3>

      <ul>
        <li>If public key is used to encrypt the message, only the private key can be used to decrypt the message.</li>
        <li>If private key is used to encrypt the message, only the public key can be used to decrypt the message.</li>
      </ul>

      <p>
        Alice shares public key to rest of the world including Bob. Bob uses it to encrypt data and send to Alice. Alice
        decrypts with private key. Nobody else can decrypt it since they don't have private key
      </p>

      <h3>Jac plays the trick</h3>

      <p>
        Jac can access Alice's public key since it is shared to the world. Jac uses Alice's public key and sends Alice a
        message impersonating Bob "Hello, I am Bob !". Alice will be able to decrypt it with her private key. Alice
        thinks it came from Bob, and may respond to him!
      </p>
      <p>
        To avoid this, digital signatures are used. Bob signs the message using Bobs private key. Alice always uses Bobs
        shared public key to verify the signature. Now Jac cannot impersonate Bob since Jac don't have Bobs private key
        to sign the message.
      </p>

      <p>
        A protocol like TLS includes the full mechanism to handle all these aspects using digital signatures. To know
        more about TLS, visit: below article:
      </p>
      <p><a href="../03/03.html">TLS Explained</a></p>

      <p>
        ssl library performs the verification of certificate date, CA signature verification by default. This is part of
        TLS handshake protocol specficcation.
      </p>
      <p>
        A check is required to ensure that the domain mentioned in the certificate and the domain is used in the
        connection is matching. This check is not part of TLS protocol, but it is avalable as part of the ssl libraries.
        During the TLS connection establishment time, ssl library is given in the input parameter of the domain or IP to
        validate against. When the digital certificate is downloaded as part of the TLS handshake, ssl library checks
        the download IP and IP mentioned in the certificate is matching. Certificate validation will be failiing if not
        matching. This is an optional feature of the ssl library.
      </p>
      <p>
        Similarly a certificate revocation checks are also done in ssl library, but it is not part of the TLS protocol.
      </p>
      <h2>What is a digital certificate ?</h2>

      <p>A digital certificate is a file that contains following compoenents:</p>
      <ul>
        <li>Public Key</li>
        <li>Digital signature of the certificate hash</li>
        <li>Asymmetric encryption algorithm used</li>
        <li>Hashing and Signature Algorithm used, like sha256RSA</li>
        <li>Certificate version</li>
        <li>Issuer - Name of the CA that issued and signed the certificate</li>
        <li>Subject - Subject to which this certificate is assigned</li>
        <li>And more ...</li>
      </ul>
      <h3>Digital certificate standard</h3>
      <p>
        X509 is a standard for publick key digital certificate. All X509 objects are represented in Abstract Syntax
        Notation One as a byte array.
      </p>

      <h3>Digital certificate file encoding formats</h3>
      <p>Below are the popular certificate file formats:</p>
      <ul>
        <li>PEM - X509 in ASCII format (Base64 encoded)</li>
        <li>DER - X509 in binary format (ASN1 encoded in binary)</li>
        <li>
          PKCS12 - A password-protected container format that contains both public and private certificate pairs. It is
          fully encrypted. This can contain private key and certificate chain material. This is a Microsoft standard.
        </li>

        <li>PKCS7 - Does not contain private key material. This is a Java open standard</li>

        <li>CER - Windows certificate file name in PEM or DER format. Only extension is changed</li>
        <li>CRT - Unix certificate file name in PEM or DER format. Only extension is changed</li>
        <li>And more ...</li>
      </ul>
      <h3>Signature Algorithms</h3>

      <p>
        In a digital certificate (like an X.509 certificate), the portion that gets signed is called the
        "TBSCertificate"(To Be Signed Certificate). After signing The result is stored in the signatureValue field of
        the certificate"
      </p>

      <figure>
        <img src="cert_signed_part.png" alt="Signed Portion of a certificate" width="400" height="120" />
        <figcaption>Signed Portion of a certificate</figcaption>
      </figure>

      <p>Signing process</p>
      <ul>
        <li>Hash the data using algorithms like SHA-1</li>
        <li>Encrypt the digest with the sender's private RSA key</li>
        <li>The result stored in signatureValue field of the certificate</li>
      </ul>
      <p>Various algorithms can be used for signing it. Examples below:</p>
      <ul>
        <li>
          RSA-Based Signature Algorithms
          <ul>
            <li>sha1WithRSAEncryption - Deprecated</li>
            <li>sha256WithRSAEncryption - Secure</li>
            <li>sha384WithRSAEncryption - Stronger</li>
            <li>sha512WithRSAEncryption - Strongest</li>
          </ul>
        </li>
        <li>
          ECDSA-Based Signature Algorithms
          <ul>
            <li>ecdsa-with-SHA1 - Deprecated</li>
            <li>ecdsa-with-SHA256 - Common</li>
            <li>ecdsa-with-SHA384 - Stronger</li>
            <li>ecdsa-with-SHA512 - Strongest</li>
          </ul>
        </li>
        <li>
          EdDSA-Based Signature Algorithms
          <ul>
            <li>Ed25519 - Fast, strong, and modern</li>
            <li>Ed448 - Even stronger but less commonly supported</li>
          </ul>
        </li>
        <li>
          RSA-PSS (Probabilistic Signature Scheme)
          <ul>
            <li>RSASSA-PSS - More secure than PKCS#1 v1.5 RSA</li>
          </ul>
        </li>
        <li>
          Deprecated / Legacy Algorithms (Avoid)
          <ul>
            <li>md5WithRSAEncryption - MD5 is broken</li>
            <li>sha1WithRSAEncryption - SHA-1 is broken</li>
            <li>ecdsa-with-SHA1 - SHA-1 is broken</li>
          </ul>
        </li>
      </ul>
      <h3>Fingerprint Algorithms</h3>
      <ul>
        <li>
          A signature is created by the issuer using their private key, and it's used to validate the authenticity of
          the certificate
        </li>
        <li>A fingerprint is a hash value of the certificate's entire DER-encoded content (binary format).</li>
        <li>
          A fingerprint is just a hash — no signing involved. It's used more for identification and comparison than
          validation
        </li>
        <li>
          If any part of the certificate is modified (even one bit), the fingerprint will change. You can manually
          verify the fingerprint against a known trusted value — for example, if your organization publishes the correct
          fingerprint for internal servers
        </li>
        <li>
          Typical fingerprint algorithms used
          <ul>
            <li>SHA-1 (legacy)</li>
            <li>SHA-256 (modern, recommended)</li>
            <li>MD5 (deprecated, insecure)</li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
          Usecases
          <ul>
            <li>
              Certificate Trust Verification
              <ul>
                <li>
                  Manually verifying a certificate from a source (website, app, server) - “Here’s the SHA-256
                  fingerprint of our SSL certificate. Make sure it matches.”. Example: SSH key verification or
                  installing a root CA cert
                </li>
                <li>
                  You compare the fingerprint shown locally to the one published on a trusted website or document. If
                  they match, you can trust it. If they don’t tampering might’ve occurred
                </li>
              </ul>
            </li>
            <li>
              SSH Host Key Verification
              <ul>
                <li>
                  "Is this the real server, or is someone pretending to be it?" - The first time you connect, you have
                  to trust the fingerprint or compare it with a known-good value
                </li>
                <li>
                  When you ssh for first time, you may see a message "The authenticity of host 'example.com' can't be
                  established. RSA key fingerprint is SHA256:abcd1234...Are you sure you want to continue? "
                </li>
                <li>This is a fingerprint of the server’s SSH key.</li>
                <li>At this point, you're supposed to compare this fingerprint to a value provided by your sysadmin</li>
                <li>
                  Working
                  <ul>
                    <li>SSH client receives the server's public key</li>
                    <li>SSH client It hashes that key using a fingerprint algorithm</li>
                    <li>It compares that hash against any known fingerprints in your ~/.ssh/known_hosts file</li>
                    <li>If it matches, you're good</li>
                    <li>If it doesn't, you get a warning (maybe a MITM attack, or maybe the server reinstalled).</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              Certificate Pinning
              <ul>
                <li>
                  Mobile apps and web apps can “pin” a fingerprint (SHA-256 of the cert) instead of trusting just a CA
                </li>
                <li>
                  Even if a valid cert is issued by a trusted CA, if it doesn't match the pinned fingerprint, the app
                  refuses to connect
                </li>
                <li>Used by banks, messengers, and secure apps</li>
                <li>
                  In ssh, you can manually pin a known fingerprint to a host using the known_hosts file . This prevents
                  SSH from silently accepting unknown keys
                </li>
              </ul>
            </li>
            <li>
              Identifying and Organizing Certificates
              <ul>
                <li>
                  In enterprise environments with hundreds or thousands of certs, fingerprints help you track and
                  identify specific certificates
                </li>
                <li>
                  Tools like browsers, certificate managers, and cloud dashboards often show fingerprints for visual
                  verification
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <h3>Self signed digital certificates</h3>
      <p>
        A self-signed certificate is a digital certificate that is signed by the entity it is issued to, rather than a
        trusted Certificate Authority (CA).
      </p>
      <p>In a self signed certificate:</p>
      <ul>
        <li>The issuer and subject are the same</li>
        <li>It’s signed with its own private key, not by a certificate authority (CA).</li>
      </ul>
      <p>You’ll usually also get a big "Not Trusted" warning unless you’ve added it to your trusted store</p>
      <h3>Common types of digital certificates</h3>
      <p>
        Although underlying technology is the same, there are different types of digital certificates depending on the
        use
      </p>
      <ul>
        <li>
          SSL/TLS Certificates- Validates server identity.
          <ul>
            <li>CN (domain), SAN, Org, Issuer, Expiry, Public Key</li>
          </ul>
        </li>

        <li>
          Code Signing Certificates - Validates Software origin and integrity.
          <ul>
            <li>CN (Developer/Org), Issuer, Serial, EKU (code signing), Expiry</li>
          </ul>
        </li>
        <li>
          Email Certificates (S/MIME) - Validates Sender identity and message integrity .
          <ul>
            <li>CN (User), Email, Issuer, Serial, Expiry, Usage (email)</li>
          </ul>
        </li>
        <li>
          Client Certificates - Validates Client/user identity, Works like a digital ID card.
          <ul>
            <li>CN (User/Device), Serial, Issuer, EKU (client auth)</li>
          </ul>
        </li>

        <li>
          Server Certificates - Validates Server identity.
          <ul>
            <li>CN (domain), SAN, Org, Issuer, Expiry, Key Usage (Server</li>
          </ul>
          Auth)
        </li>

        <li>
          Document Signing Certificates - Validates Signer identity and document integrity.
          <ul>
            <li>CN (Person/Org), Serial, Issuer, Key Usage (Doc Signing), Expiry</li>
          </ul>
        </li>

        <li>
          Root Certificates - Establishing trust for all certs.
          <ul>
            <li>CN, Org, Serial, Self-signed, Public Key</li>
          </ul>
        </li>

        <li>
          Intermediate Certificates - Bridging trust from root to leaf. – Issued by a root or another intermediate CA to
          help distribute trust securely. Validates Root CA authenticity, and Chain of trust .
          <ul>
            <li>CN, Org, Serial, Signed by Root, Public Key</li>
          </ul>
        </li>
      </ul>
      <h3>Non X.509 digital certificates</h3>
      <ul>
        <li>
          PGP Certificates (Pretty Good Privacy)
          <ul>
            <li>Format: OpenPGP</li>
            <li>Not based on X.509 at all</li>
            <li>Used in email encryption, file signing, and tools like GnuPG (GPG)</li>
            <li>No central certificate authority (CA); uses a "web of trust" model instead of PKI.</li>
            <li>Certificates contain: User ID (name, email), Public key, Signatures from other users (for trust)</li>
            <li>Decentralized trust, user-to-user verification</li>
          </ul>
        </li>
        <li>
          SSH Public Keys
          <ul>
            <li>Not certificates in the X.509 sense, but they’re used to authenticate users/hosts</li>
            <li>
              SSH keys are raw key pairs (e.g., RSA, Ed25519), often stored in: ~/.ssh/id_rsa.pub,
              /etc/ssh/ssh_host_rsa_key.pub
            </li>
            <li>Can optionally be wrapped in OpenSSH certificate format</li>
            <li>These certificates are not X.509, but serve a similar purpose (signed public keys with metadata)</li>
            <li>Lightweight, flexible, and mostly used in internal or dev environments</li>
          </ul>
        </li>
        <li>
          S/MIME Certificates (Older Versions)
          <ul>
            <li>
              Modern S/MIME uses X.509, but some older or proprietary formats used custom certificate structures. Some
              early email systems or vendors had their own crypto formats before standards unified around X.509
            </li>
          </ul>
        </li>
        <li>
          JSON Web Tokens (JWTs) with Public Keys
          <ul>
            <li>Not exactly certificates, but serve similar purposes in identity and authorization</li>
            <li>A JWT can include a JWK (JSON Web Key), which can be verified using a public key</li>
            <li>Common in OAuth 2.0, OpenID Connect, and API token systems</li>
            <li>Web-native, token-based identity, often with signed payloads</li>
          </ul>
        </li>
      </ul>
      <h3>Fields in digital certificates X.509</h3>
      <p>
        X.509 digital certificates, commonly used in SSL/TLS for secure communication, have a standardized structure
        defined by the X.509 specification
      </p>
      <ul>
        <li>
          Basic Certificate Fields
          <ul>
            <li>Version - Indicates the X.509 version (v1, v2, v3).</li>
            <li>Serial Number - A unique identifier assigned by the issuing Certificate Authority (CA)</li>
            <li>Signature Algorithm - Specifies the algorithm used by the CA to sign the certificate</li>
            <li>
              Issuer - The entity that issued the certificate (usually a CA). Includes details like Common Name (CN),
              Organization (O), Country (C), etc
            </li>
            <li>
              Validity Period - Not Before: The start date/time the certificate is valid, Not After: The expiry
              date/time
            </li>
            <li>
              Subject - The entity the certificate is issued to. Includes fields like Common Name (CN), Organization,
              Country, etc
            </li>
            <li>
              Subject Public Key Info - Algorithm: The public key algorithm (e.g., RSA, ECDSA), Public Key: The actual
              public key
            </li>
          </ul>
        </li>
        <li>
          Extensions (v3 certificates only)
          <ul>
            <li>
              Basic Constraints - Indicates if the certificate is a CA certificate or not. Example: CA:TRUE or CA:FALSE
            </li>
            <li>
              Key Usage - Specifies the intended usage of the public key . Examples: Digital Signature, Key
              Encipherment, Certificate Signing
            </li>
            <li>
              Extended Key Usage - More specific usage purposes. Examples: TLS Web Server Authentication, Code Signing
            </li>
            <li>
              Subject Alternative Name (SAN) - Lists additional identities like DNS names or IP addresses. Crucial for
              modern HTTPS (often more important than CN).
            </li>
            <li>CRL Distribution Points - URL(s) where the Certificate Revocation List can be obtained</li>
            <li>Authority Key Identifier - Identifies the public key of the CA that issued the certificate</li>
            <li>Subject Key Identifier - A unique identifier for the certificate’s public key</li>
            <li>
              Authority Information Access - Provides methods to access the issuing CA’s certificate or Online
              Certificate Status Protocol (OCSP) responder
            </li>
          </ul>
        </li>
      </ul>
      <h3>Importance of Subject Alternative Name (SAN)</h3>

      <ul>
        <li>
          The Subject Alternative Name (SAN) is one of the most important extensions in modern X.509 certificates,
          especially for web security and HTTPS
        </li>
        <li>
          SAN replaces the Common Name (CN) for domain validation
          <ul>
            <li>Historically, the Common Name (CN) field in the Subject was used to specify the hostname</li>
            <li>Modern browsers and clients now rely on SAN instead of CN to validate the domain</li>
            <li>
              If SAN is missing, many clients (especially modern browsers like Chrome, Firefox) will reject the
              certificate, even if the CN is correct
            </li>
          </ul>
        </li>
        <li>
          Supports multiple domain names
          <ul>
            <li>
              SAN allows a single certificate to secure multiple domains or subdomains, like:
              <ul>
                <li>example.com, www.example.com, mail.example.com, api.anotherdomain.com</li>
              </ul>
            </li>
            <li>
              This is particularly useful for: Multi-domain SSL certificates, Wildcard-like support (to some extent,
              though not identical)
            </li>
          </ul>
        </li>
      </ul>
      <h3>Wildcard digital certificates</h3>
      <p>
        A wildcard certificate is a type of SSL/TLS certificate that secures a domain and all of its subdomains at a
        single level using a wildcard character (*).
      </p>
      <p>
        Certificate for *.example.com covers: www.example.com, mail.example.comm blog.example.com etc. But it does not
        cover: sub.mail.example.com (that’s a second-level subdomain) or example.org (different root domain)
      </p>

      <p>Usecases</p>
      <ul>
        <li>
          Hosting multiple subdomains on a single certificate. Example: A web hosting company with clients on
          client1.hosting.com, client2.hosting.com, etc. Saves cost and effort compared to managing separate certs
        </li>
        <li>
          Dynamic subdomain creation. Great for SaaS platforms where each customer gets a subdomain (e.g.,
          user1.app.com, user2.app.com).
        </li>
        <li>
          Simplifies certificate management - Fewer certificates to track and renew. Ideal for organizations with large
          internal infrastructure or microservices architecture
        </li>
        <li>Cons - Security risk: If one private key is compromised, all subdomains are vulnerable</li>
        <li>Cons - Doesn't cover deeper levels: *.example.com ≠ a.b.example.com</li>
        <li>Cons - Some Certificate Authorities limit wildcard support (e.g., not allowed for EV certs)</li>
      </ul>
      <h3>SHA-1 digital certificate</h3>
      <ul>
        <li>
          A SHA-1 digital certificate is an X.509 certificate (used in HTTPS, email security, code signing, etc.) that
          uses the SHA-1 (Secure Hash Algorithm 1) cryptographic hash function in one or more of the following areas:
          <ul>
            <li>
              Signature Algorithm – The certificate is digitally signed by a Certificate Authority (CA) using SHA-1,
              often shown as something like sha1WithRSAEncryption.
            </li>
            <li>
              Thumbprint / Fingerprint – SHA-1 is used to generate a fingerprint of the certificate (not related to
              trust, just an identifier).
            </li>
          </ul>
        </li>
        <li>
          SHA-1 certificate is deprecated as it is considered cryptographically broken. Most browsers, operating
          systems, and CAs now reject or warn against SHA-1 certificates
          <ul>
            <li>Signature Algorithm: sha1WithRSAEncryption - is not ok</li>
            <li>
              Fingerprint Algorithm: SHA-1 Fingerprint - is ok. still common for identification, not used for security
            </li>
          </ul>
        </li>
        <li>SHA-256 or better (SHA-2 family) is now the standard</li>
      </ul>

      <h3>SHA-2 digital certificate</h3>
      <ul>
        <li>Most Common Today.</li>
        <li>SHA-2 family of hash functions includes - SHA-224, SHA-256 (most widely used), SHA-384, SHA-512</li>
      </ul>

      <h2>Working of PKI</h2>
      <ol>
        <li>You will generate a key-pair</li>
        <li>You will keep the private key secret</li>
        <li>
          Certificate Signing Request (CSR) is made for a domain name or multiple domain names. CSR includes your public
          key information and information about your domain inside a configuration file. CSR is then sent to CA. Below
          command generate key pair having password protected private key, and a CSR.

          <p>$ openssl req -newkey rsa:2048 -keyout crispinjacob.com.key -out crispinjacob.com.csr</p>
        </li>
        <li>
          CA verifies crispinjacob.com.csr and signs your public key and related information in the form of a signed
          public key certificate
        </li>
        <li>You will install your signed certificate in your server</li>
        <li>
          You will install your private key in your server. This private key is password protected while generating it.
          Only your server can use this private key.
        </li>
        <li>
          A webbrowwer or client application access your server and TLS handshake occures, and publick key certificate
          is downloaded to browser as part of HTTPS handshake
        </li>
        <li>
          Browser verifies the received server certificate before trusting it - validiyt, connected domain and domain
          name the certificate and so on.
        </li>
        <li>
          The certificate verification is baed on a trust achor that browser has access to. Trust anchor is a CA
          certificate that is often distribuited along with browser, or store in the OS that the browser trusts. Browser
          expects the downloaded server certificate is signed by this CA certificate (trust anchor)
        </li>
        <li>
          In most cases the server certificate is not signed by the root CA that comes with OS or brower. That will be
          another CA that the trust anchor CA trusts . This is called an intermediate CA. <br />
          In this case, the brower checks who signed the intermediate certificate. If it is signed by one of the trust
          Anchors then the brower trusts the downloaded server certificate. This verification is performed by decrypting
          that intermediate CA signature using trust anchors (root CA) public key.
        </li>

        <li>
          Often a further lower hierarchy CA might have signed the server certificate. <br />
          in this case, the brower verifies the issuer CA signed the server certificate, by decrypting server
          certificate signature with issuer CA public key. Then browser verifies the parent CA that signed the CA. This
          process goes from leaf node server certificate, up till trust anchror which is often the trust anchor
          certificate. If successful, at that point , the trust is established on the serer certificate. <br />
          Note that if you install one of the intermediate CA certificate in your brower/OS, then that will be your
          trust anchor, and you dont need to check till root CA. Often the entire chain of certificate is downloaded in
          single shot during TLS handshake. Note that if your browser misses one of the intermediate certificates, then
          your certificate's verification will fail.
        </li>
      </ol>

      <h3>Certificate Chain</h3>
      <p>
        Server certificate chain is sent as part of the TLS handshake. Certificate chain is based on chain of trust
        concept.
      </p>
      <p>
        The sender decides the certificates includes in the certificate chain. For example sender may exclude
        unnecessary certificates, like trusted root certificate. It's considered a best practice to configure your
        webserver to deliver the full chain.

        <br />
        If the certificate chain size exceeds TCP’s initial congestion window, it caan cause roundtrips to the TLS
        handshake. As newer TCP stack has initial congestion window increased to 10 TCP segments this is sufficient for
        most certificate chains.
      </p>

      <h3>Revoking a certificate</h3>
      <p>
        One method is to periodically download Certificate Revocation List (CRL) and inspect every certificate in the
        list. If the certificate is in revocation list , the certificate verification will be made to fail. This is not
        a scalable nechanism.
      </p>

      <p>
        The alternate mechanism is to use a protocol Online Certificate Status Protocol (OCSP).OCSP helps the client to
        check the validity of the certificate using a query instead of storing a list. The CA also need to support OCSP
        protocol.
      </p>

      <p>
        In OCSP Stapling protocol, the server retrieves OCSP response and sends to client during the handshake. As OCSP
        resonse is signed by CA, the client can verify it
      </p>

      <h3>What if a popular CA creates a fake certificate and setup a fake webserver ?</h3>
      <p>
        Often the rootCAs are and trusted. But when it comes to intermediates CAs of small size, there is a possibility
        of malicios actors. If your intermedicate CA issues a fake certificate using your domain name, you wont come to
        know about it. This certificate can be used for man in the middle attack since the brower will trust your domain
        name
      </p>

      <h2>References</h2>
      <ul>
        <li>
          https://crypto.stackexchange.com/questions/93641/can-we-pick-which-key-is-private-or-public-in-asymmetric-encryption-do-the-keys
        </li>
        <li>https://docs.openssl.org/1.1.1/man1/ciphers/#tls-v12-cipher-suites</li>
      </ul>
    </div>
  </body>
</html>