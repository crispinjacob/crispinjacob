<!doctype html>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
<link rel="stylesheet" type="text/css" href="../../styles/commonstyles.css" />
<link rel="stylesheet" href="../../styles/blogstyle.css" />
<link rel="stylesheet" href="../../styles/iconbarstyle.css" />
<link rel="stylesheet" href="../../styles/toc.css" />

<html lang="en-us">
  <head>
    <title>Digital Certificates</title>
  </head>

  <body>
    <div class="icon-bar">
      <a class="active" href="../../index.html"><i class="fa fa-home"></i></a>
    </div>

    <div style="padding: 20px">
      <h1>Digital Certificates</h1>

      <p>16 March 2025</p>
      <hr />

      <div id="toc"></div>
      <script src="../../scripts/toc.js"></script>

      <p>
        Digital Certificates are one of the foundation blocks of security in digital world. They are used to
        authenticate the identity of the device and secure the transactions between devices. Digital certificate is a
        data structure that contains various parameters that can be used to establish trust. This section provides an
        overview of the digital certificates.
      </p>
      <p>Let us dive into few concepts:</p>

      <h2>Symmetric key cryptography</h2>
      <p>In Symmetric key cryptography same key is used to encrypt and decrypt.</p>
      <ul>
        <li>Advantage: They are faster to encrypt and decrypt</li>
        <li>Disadvantage: The secret key has to be shared between the sender and receiver.</li>
      </ul>

      <p>
        Secure key distribution is a major problem to be solved, and this is where the Asymmetric key cryptography
        excells
      </p>

      <h2>Asymmetric key cryptography (public key cryptography)</h2>

      <p>
        Asymmetric key cryptography solves the above mentioned key distribution problem by using 2 keys (key pair)
        instead of a single shared key.
      </p>
      <ul>
        <li>One of the keys is kept secret - private key</li>
        <li>Other key is made public - public key</li>
      </ul>

      <p>
        There are different algorithm choices available for asymmetric key cryptography. Some of the popular ones are:
      </p>
      <ul>
        <li>
          RSA - Rivest–Shamir–Adleman.
          <ul>
            <li>Most suited for communication encryption</li>
            <li>Based on difficulty of Prime factorization</li>
          </ul>
        </li>

        <li>
          DSA - Digital Signature Algorithm
          <ul>
            <li>Most suited for signing (encrypting hash) and verification</li>
            <li>Based on difficulty of discrete logarithm</li>
          </ul>
        </li>

        <li>
          ECC- Elliptic Curve Cryptography
          <ul>
            <li>Greater cryptographic strengh for equivalent key size in RSA/DSA</li>
          </ul>
        </li>
      </ul>

      <p>
        Some algorithms like RSA technically allows YOU to choose which key is private and which is public. But some
        others like ECC does not give you a choice as they are dissimilar in computation.
      </p>
      <p></p>

      <h2>Hybrid approach</h2>
      <p>
        The Asymetric encryption is computationally heavy (could be 1000s of times heavy) as compared to the symmetric
        encryption. In practical usecases a hybrid approach is used where public key cryptography is used for securely
        sharing symmetric key. After this initial step, the symmetric key is used always.
      </p>
      <p>Majority of the communication encryption usecases follows a hybrid approch.</p>

      <h2>Assumetric encryption - Key aspects</h2>

      <h3>Sharing</h3>
      <p></p>
      <ul>
        <li>Public keys can be shared to anyone publicly. There is no secrecy involved here.</li>
        <li>Private keys are not shared with anyone else.</li>
      </ul>

      <p>Public keys can be shared via different mechanisms . For example:</p>
      <ul>
        <li>Manually via email or similar mechanisms</li>
        <li>Using a protocol, like TLS</li>
      </ul>

      <h3>Oneway Encryption</h3>

      <ul>
        <li>If public key is used to encrypt the message, only the private key can be used to decrypt the message.</li>
        <li>If private key is used to encrypt the message, only the public key can be used to decrypt the message.</li>
      </ul>

      <p>
        Alice shares public key to rest of the world including Bob. Bob uses it to encrypt data and send to Alice. Alice
        decrypts with private key. Nobody else can decrypt it since they don't have private key
      </p>

      <h3>Jac plays the trick</h3>

      <p>
        Jac can access Alice's public key since it is shared to the world. Jac uses Alice's public key and sends Alice a
        message impersonating Bob "Hello, I am Bob !". Alice will be able to decrypt it with her private key. Alice
        thinks it came from Bob, and may respond to him!
      </p>
      <p>
        To avoid this, digital signatures are used. Bob signs the message using Bobs private key. Alice always uses Bobs
        shared public key to verify the signature. Now Jac cannot impersonate Bob since Jac don't have Bobs private key
        to sign the message.
      </p>

      <p>
        A protocol like TLS includes the full mechanism to handle all these aspects using digital signatures. To know
        more about TLS, visit: below article:
      </p>
      <p><a href="../03/03.html">TLS Explained</a></p>

      <p>
        ssl library performs the verification of certificate date, CA signature verification by default. This is part of
        TLS handshake protocol specficcation.
      </p>
      <p>
        A check is required to ensure that the domain mentioned in the certificate and the domain is used in the
        connection is matching. This check is not part of TLS protocol, but it is avalable as part of the ssl libraries.
        During the TLS connection establishment time, ssl library is given in the input parameter of the domain or IP to
        validate against. When the digital certificate is downloaded as part of the TLS handshake, ssl library checks
        the download IP and IP mentioned in the certificate is matching. Certificate validation will be failiing if not
        matching. This is an optional feature of the ssl library.
      </p>
      <p>
        Similarly a certificate revocation checks are also done in ssl library, but it is not part of the TLS protocol.
      </p>
      <h2>What is a digital certificate ?</h2>

      <p>A digital certificate is a file that contains following compoenents:</p>
      <ul>
        <li>Public Key</li>
        <li>Digital signature of the certificate hash</li>
        <li>Asymmetric encryption algorithm used</li>
        <li>Hashing and Signature Algorithm used, like sha256RSA</li>
        <li>Certificate version</li>
        <li>Issuer - Name of the CA that issued and signed the certificate</li>
        <li>Subject - Subject to which this certificate is assigned</li>
        <li>And more ...</li>
      </ul>
      <h3>Digital certificate standard</h3>
      <p>
        X509 is a standard for publick key digital certificate. All X509 objects are represented in Abstract Syntax
        Notation One as a byte array.
      </p>

      <h3>Digital certificate file encoding formats</h3>
      <p>Below are the popular certificate file formats:</p>
      <ul>
        <li>PEM - X509 in ASCII format (Base64 encoded)</li>
        <li>DER - X509 in binary format (ASN1 encoded in binary)</li>
        <li>
          PKCS12 - A password-protected container format that contains both public and private certificate pairs. It is
          fully encrypted. This can contain private key and certificate chain material. This is a Microsoft standard.
        </li>

        <li>PKCS7 - Does not contain private key material. This is a Java open standard</li>

        <li>CER - Windows certificate file name in PEM or DER format. Only extension is changed</li>
        <li>CRT - Unix certificate file name in PEM or DER format. Only extension is changed</li>
        <li>And more ...</li>
      </ul>
      <h3>Signature Algorithms</h3>

      <p>
        In a digital certificate (like an X.509 certificate), the portion that gets signed is called the
        "TBSCertificate"(To Be Signed Certificate). After signing The result is stored in the signatureValue field of
        the certificate"
      </p>

      <figure>
        <img src="cert_signed_part.png" alt="Signed Portion of a certificate" width="400" height="120" />
        <figcaption>Signed Portion of a certificate</figcaption>
      </figure>

      <p>Signing process</p>
      <ul>
        <li>Hash the data using algorithms like SHA-1</li>
        <li>Encrypt the digest with the sender's private RSA key</li>
        <li>The result stored in signatureValue field of the certificate</li>
      </ul>
      <p>Various algorithms can be used for signing it. Examples below:</p>
      <ul>
        <li>
          RSA-Based Signature Algorithms
          <ul>
            <li>sha1WithRSAEncryption - Deprecated</li>
            <li>sha256WithRSAEncryption - Secure</li>
            <li>sha384WithRSAEncryption - Stronger</li>
            <li>sha512WithRSAEncryption - Strongest</li>
          </ul>
        </li>
        <li>
          ECDSA-Based Signature Algorithms
          <ul>
            <li>ecdsa-with-SHA1 - Deprecated</li>
            <li>ecdsa-with-SHA256 - Common</li>
            <li>ecdsa-with-SHA384 - Stronger</li>
            <li>ecdsa-with-SHA512 - Strongest</li>
          </ul>
        </li>
        <li>
          EdDSA-Based Signature Algorithms
          <ul>
            <li>Ed25519 - Fast, strong, and modern</li>
            <li>Ed448 - Even stronger but less commonly supported</li>
          </ul>
        </li>
        <li>
          RSA-PSS (Probabilistic Signature Scheme)
          <ul>
            <li>RSASSA-PSS - More secure than PKCS#1 v1.5 RSA</li>
          </ul>
        </li>
        <li>
          Deprecated / Legacy Algorithms (Avoid)
          <ul>
            <li>md5WithRSAEncryption - MD5 is broken</li>
            <li>sha1WithRSAEncryption - SHA-1 is broken</li>
            <li>ecdsa-with-SHA1 - SHA-1 is broken</li>
          </ul>
        </li>
      </ul>
      <h3>Fingerprint Algorithms</h3>
      <ul>
        <li>
          A signature is created by the issuer using their private key, and it's used to validate the authenticity of
          the certificate
        </li>
        <li>A fingerprint is a hash value of the certificate's entire DER-encoded content (binary format).</li>
        <li>
          A fingerprint is just a hash — no signing involved. It's used more for identification and comparison than
          validation
        </li>
        <li>
          If any part of the certificate is modified (even one bit), the fingerprint will change. You can manually
          verify the fingerprint against a known trusted value — for example, if your organization publishes the correct
          fingerprint for internal servers
        </li>
        <li>
          Typical fingerprint algorithms used
          <ul>
            <li>SHA-1 (legacy)</li>
            <li>SHA-256 (modern, recommended)</li>
            <li>MD5 (deprecated, insecure)</li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
          Usecases
          <ul>
            <li>
              Certificate Trust Verification
              <ul>
                <li>
                  Manually verifying a certificate from a source (website, app, server) - “Here’s the SHA-256
                  fingerprint of our SSL certificate. Make sure it matches.”. Example: SSH key verification or
                  installing a root CA cert
                </li>
                <li>
                  You compare the fingerprint shown locally to the one published on a trusted website or document. If
                  they match, you can trust it. If they don’t tampering might’ve occurred
                </li>
              </ul>
            </li>
            <li>
              SSH Host Key Verification
              <ul>
                <li>
                  "Is this the real server, or is someone pretending to be it?" - The first time you connect, you have
                  to trust the fingerprint or compare it with a known-good value
                </li>
                <li>
                  When you ssh for first time, you may see a message "The authenticity of host 'example.com' can't be
                  established. RSA key fingerprint is SHA256:abcd1234...Are you sure you want to continue? "
                </li>
                <li>This is a fingerprint of the server’s SSH key.</li>
                <li>At this point, you're supposed to compare this fingerprint to a value provided by your sysadmin</li>
                <li>
                  Working
                  <ul>
                    <li>SSH client receives the server's public key</li>
                    <li>SSH client It hashes that key using a fingerprint algorithm</li>
                    <li>It compares that hash against any known fingerprints in your ~/.ssh/known_hosts file</li>
                    <li>If it matches, you're good</li>
                    <li>If it doesn't, you get a warning (maybe a MITM attack, or maybe the server reinstalled).</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              Certificate Pinning
              <ul>
                <li>
                  Mobile apps and web apps can “pin” a fingerprint (SHA-256 of the cert) instead of trusting just a CA
                </li>
                <li>
                  Even if a valid cert is issued by a trusted CA, if it doesn't match the pinned fingerprint, the app
                  refuses to connect
                </li>
                <li>Used by banks, messengers, and secure apps</li>
                <li>
                  In ssh, you can manually pin a known fingerprint to a host using the known_hosts file . This prevents
                  SSH from silently accepting unknown keys
                </li>
              </ul>
            </li>
            <li>
              Identifying and Organizing Certificates
              <ul>
                <li>
                  In enterprise environments with hundreds or thousands of certs, fingerprints help you track and
                  identify specific certificates
                </li>
                <li>
                  Tools like browsers, certificate managers, and cloud dashboards often show fingerprints for visual
                  verification
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <h3>Self signed digital certificates</h3>
      <p>
        A self-signed certificate is a digital certificate that is signed by the entity it is issued to, rather than a
        trusted Certificate Authority (CA).
      </p>
      <p>In a self signed certificate:</p>
      <ul>
        <li>The issuer and subject are the same</li>
        <li>It’s signed with its own private key, not by a certificate authority (CA).</li>
      </ul>
      <p>You’ll usually also get a big "Not Trusted" warning unless you’ve added it to your trusted store</p>

      <h3>Types of digital certificates</h3>
      <p>
        Although underlying technology is the same, there are different types of digital certificates depending on the
        usecases. Digital certificates can be categorized based on differences in X.509 fields.
      </p>

      <ol>
        <li>
          By Validation Level (based on Subject fields and CA checks)

          <ul>
            <li>These differ mainly in the Subject field and what the CA verifies before issuing</li>
            <li>
              Domain Validation (DV) Certificates. Domain ownership only.Basic website encryption.
              <ul>
                <li>Validates: Only the domain ownership</li>
                <li>Subject Fields: Minimal — typically just CN or SAN with the domain name</li>
                <li>Usage: Basic HTTPS for websites</li>
                <li>SAN field must match the domain</li>
                <li>Subject fields like Organization (O), Location (L), etc. are often blank or not validated</li>
              </ul>
            </li>
            <li>
              Organization Validation (OV) Certificates
              <ul>
                <li>Validates: Domain ownership and the organization's identity</li>
                <li>Subject Fields: CN, O (Organization), C (Country), L (City), ST (State).</li>
                <li>Usage: Business websites, APIs, internal tools</li>
                <li>Includes full Subject DN fields with verified organizational info</li>
                <li>May include organization info in certificate extensions</li>
              </ul>
            </li>
            <li>
              Extended Validation (EV) Certificates
              <ul>
                <li>Validates: Domain ownership and a rigorous check of the organization's legal identity</li>
                <li>Subject Fields: Same as OV but with stricter verification</li>
                <li>Usage: High-trust websites (banks, e-commerce, etc.).</li>
                <li>Same fields as OV, but often includes special OID in extensions (e.g., EV policy OIDs)</li>
                <li>Recognized by browsers with visible indicators (green bar in older browsers, etc.).</li>
              </ul>
            </li>
          </ul>
        </li>

        <li>
          By Usage (based on Key Usage & Extended Key Usage extensions)
          <ul>
            <li>These differ in keyUsage and extendedKeyUsage fields</li>
            <li>
              SSL/TLS Certificates
              <ul>
                <li>Purpose: Secure websites (HTTPS).</li>
                <li>Key Usage: Digital Signature, Key Encipherment</li>
                <li>Extended Key Usage: TLS Web Server Authentication, TLS Web Client Authentication</li>
              </ul>
            </li>
            <li>
              Email Certificates (S/MIME)
              <ul>
                <li>Purpose: Secure email communications</li>
                <li>Key Usage: Digital Signature, Key Encipherment</li>
                <li>Extended Key Usage: Email Protection</li>
                <li>Subject Fields: Often includes an email address</li>
              </ul>
            </li>
            <li>
              Code Signing Certificates
              <ul>
                <li>Purpose: Verify software/app authenticity</li>
                <li>Key Usage: Digital Signature</li>
                <li>Extended Key Usage: Code Signing</li>
                <li>Subject Fields: Organization name is typically included</li>
              </ul>
            </li>
            <li>
              Client Authentication Certificates
              <ul>
                <li>Purpose: Authenticate users/systems</li>
                <li>Extended Key Usage: Client Authentication</li>
              </ul>
            </li>
            <li>
              Document Signing Certificates
              <ul>
                <li>Purpose: Sign PDFs, Word docs, etc</li>
                <li>Extended Key Usage: Document Signing</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          By Trust Model (based on issuer fields)
          <ul>
            <li>
              Root Certificates
              <ul>
                <li>Self-signed</li>
                <li>Used to sign intermediate CAs</li>
                <li>Issuer = Subject</li>
              </ul>
            </li>
            <li>
              Intermediate Certificates
              <ul>
                <li>Issued by a root or another intermediate CA</li>
                <li>Used to issue end-entity certs (like DV/OV/EV certs).</li>
                <li>Helps with trust chain hierarchy</li>
              </ul>
            </li>

            <li>
              End-Entity Certificates
              <ul>
                <li>Issued to servers, users, or devices</li>
                <li>Used in actual authentication/communication</li>
                <li>
                  Cannot sign other certificates (CA:FALSE in Basic Constraints). Need for this: If a certificate
                  without CA:FALSE is compromised and it can issue other certificates, an attacker could create fake
                  certs for any domain — a massive security risk.Root & Intermediate CAs: CA:TRUE and Leaf (end-entity)
                  certs: CA:FALSE
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>

      <h3>Non X.509 digital certificates</h3>
      <ul>
        <li>
          PGP Certificates (Pretty Good Privacy)
          <ul>
            <li>Format: OpenPGP</li>
            <li>Not based on X.509 at all</li>
            <li>Used in email encryption, file signing, and tools like GnuPG (GPG)</li>
            <li>No central certificate authority (CA); uses a "web of trust" model instead of PKI.</li>
            <li>Certificates contain: User ID (name, email), Public key, Signatures from other users (for trust)</li>
            <li>Decentralized trust, user-to-user verification</li>
          </ul>
        </li>
        <li>
          SSH Public Keys
          <ul>
            <li>Not certificates in the X.509 sense, but they’re used to authenticate users/hosts</li>
            <li>
              SSH keys are raw key pairs (e.g., RSA, Ed25519), often stored in: ~/.ssh/id_rsa.pub,
              /etc/ssh/ssh_host_rsa_key.pub
            </li>
            <li>Can optionally be wrapped in OpenSSH certificate format</li>
            <li>These certificates are not X.509, but serve a similar purpose (signed public keys with metadata)</li>
            <li>Lightweight, flexible, and mostly used in internal or dev environments</li>
          </ul>
        </li>
        <li>
          S/MIME Certificates (Older Versions)
          <ul>
            <li>
              Modern S/MIME uses X.509, but some older or proprietary formats used custom certificate structures. Some
              early email systems or vendors had their own crypto formats before standards unified around X.509
            </li>
          </ul>
        </li>
        <li>
          JSON Web Tokens (JWTs) with Public Keys
          <ul>
            <li>Not exactly certificates, but serve similar purposes in identity and authorization</li>
            <li>A JWT can include a JWK (JSON Web Key), which can be verified using a public key</li>
            <li>Common in OAuth 2.0, OpenID Connect, and API token systems</li>
            <li>Web-native, token-based identity, often with signed payloads</li>
          </ul>
        </li>
      </ul>
      <h3>PGP Certificates</h3>
      <p>
        PGP is based on decentralized trust - There’s no central authority that everyone must trust to verify
        identities. Instead, you decide who you trust, and you can trust other people's trust. This is in contrast with
        CA-based (centralized trust).
      </p>
      <p>
        In centralized trust YOU don’t decide who to trust — your software or OS does. In PGP, you build your own trust
        relationships
      </p>

      <ul>
        <li>In PGP each person generates their own key pair (no CA needed)</li>
        <li>Each person shares their public key with others (often on keyservers)</li>
        <li>Each person can sign someone else's key to vouch for it</li>
        <li>
          If you trust Alice, and Alice signs Bob’s key → you might trust Bob, too. This forms a web of signatures and
          trust links
        </li>
        <li>This is why it's called a Web of Trust — decentralized, organic, and based on human trust relationships</li>
      </ul>

      <h3>Fields in digital certificates X.509</h3>
      <p>
        X.509 digital certificates, commonly used in SSL/TLS for secure communication, have a standardized structure
        defined by the X.509 specification
      </p>
      <ul>
        <li>
          Basic Certificate Fields
          <ul>
            <li>Version - Indicates the X.509 version (v1, v2, v3).</li>
            <li>Serial Number - A unique identifier assigned by the issuing Certificate Authority (CA)</li>
            <li>Signature Algorithm - Specifies the algorithm used by the CA to sign the certificate</li>
            <li>
              Issuer - The entity that issued the certificate (usually a CA). Includes details like Common Name (CN),
              Organization (O), Country (C), etc
            </li>
            <li>
              Validity Period - Not Before: The start date/time the certificate is valid, Not After: The expiry
              date/time
            </li>
            <li>
              Subject - The entity the certificate is issued to. Includes fields like Common Name (CN), Organization,
              Country, etc
            </li>
            <li>
              Subject Public Key Info - Algorithm: The public key algorithm (e.g., RSA, ECDSA), Public Key: The actual
              public key
            </li>
          </ul>
        </li>
        <li>
          Extensions (v3 certificates only)
          <ul>
            <li>
              Basic Constraints - Indicates if the certificate is a CA certificate or not. Example: CA:TRUE or CA:FALSE
            </li>
            <li>
              Key Usage - Specifies the intended usage of the public key . Examples: Digital Signature, Key
              Encipherment, Certificate Signing
            </li>
            <li>
              Extended Key Usage - More specific usage purposes. Examples: TLS Web Server Authentication, Code Signing
            </li>
            <li>
              Subject Alternative Name (SAN) - Lists additional identities like DNS names or IP addresses. Crucial for
              modern HTTPS (often more important than CN).
            </li>
            <li>CRL Distribution Points - URL(s) where the Certificate Revocation List can be obtained</li>
            <li>Authority Key Identifier - Identifies the public key of the CA that issued the certificate</li>
            <li>Subject Key Identifier - A unique identifier for the certificate’s public key</li>
            <li>
              Authority Information Access - Provides methods to access the issuing CA’s certificate or Online
              Certificate Status Protocol (OCSP) responder
            </li>
          </ul>
        </li>
      </ul>
      <h3>Importance of Subject Alternative Name (SAN)</h3>

      <ul>
        <li>
          The Subject Alternative Name (SAN) is one of the most important extensions in modern X.509 certificates,
          especially for web security and HTTPS
        </li>
        <li>
          SAN replaces the legacy Common Name (CN) for domain validation
          <ul>
            <li>Historically, the Common Name (CN) field in the Subject was used to specify the hostname</li>
            <li>Modern browsers and clients now rely on SAN instead of CN to validate the domain</li>
            <li>
              If SAN is missing, many clients (especially modern browsers like Chrome, Firefox) will reject the
              certificate, even if the CN is correct
            </li>
          </ul>
        </li>
        <li>
          Supports multiple domain names
          <ul>
            <li>
              SAN allows a single certificate to secure multiple domains or subdomains, like:
              <ul>
                <li>example.com, www.example.com, mail.example.com, api.anotherdomain.com</li>
              </ul>
            </li>
            <li>
              This is particularly useful for: Multi-domain SSL certificates, Wildcard-like support (to some extent,
              though not identical)
            </li>
          </ul>
        </li>
      </ul>
      <h3>Wildcard digital certificates</h3>
      <p>
        A wildcard certificate is a type of SSL/TLS certificate that secures a domain and all of its subdomains at a
        single level using a wildcard character (*).
      </p>
      <p>
        Certificate for *.example.com covers: www.example.com, mail.example.comm blog.example.com etc. But it does not
        cover: sub.mail.example.com (that’s a second-level subdomain) or example.org (different root domain)
      </p>

      <p>Usecases</p>
      <ul>
        <li>
          Hosting multiple subdomains on a single certificate. Example: A web hosting company with clients on
          client1.hosting.com, client2.hosting.com, etc. Saves cost and effort compared to managing separate certs
        </li>
        <li>
          Dynamic subdomain creation. Great for SaaS platforms where each customer gets a subdomain (e.g.,
          user1.app.com, user2.app.com).
        </li>
        <li>
          Simplifies certificate management - Fewer certificates to track and renew. Ideal for organizations with large
          internal infrastructure or microservices architecture
        </li>
        <li>Cons - Security risk: If one private key is compromised, all subdomains are vulnerable</li>
        <li>Cons - Doesn't cover deeper levels: *.example.com ≠ a.b.example.com</li>
        <li>Cons - Some Certificate Authorities limit wildcard support (e.g., not allowed for EV certs)</li>
      </ul>
      <h3>SHA-1 digital certificate</h3>
      <ul>
        <li>
          A SHA-1 digital certificate is an X.509 certificate (used in HTTPS, email security, code signing, etc.) that
          uses the SHA-1 (Secure Hash Algorithm 1) cryptographic hash function in one or more of the following areas:
          <ul>
            <li>
              Signature Algorithm – The certificate is digitally signed by a Certificate Authority (CA) using SHA-1,
              often shown as something like sha1WithRSAEncryption.
            </li>
            <li>
              Thumbprint / Fingerprint – SHA-1 is used to generate a fingerprint of the certificate (not related to
              trust, just an identifier).
            </li>
          </ul>
        </li>
        <li>
          SHA-1 certificate is deprecated as it is considered cryptographically broken. Most browsers, operating
          systems, and CAs now reject or warn against SHA-1 certificates
          <ul>
            <li>Signature Algorithm: sha1WithRSAEncryption - is not ok</li>
            <li>
              Fingerprint Algorithm: SHA-1 Fingerprint - is ok. still common for identification, not used for security
            </li>
          </ul>
        </li>
        <li>SHA-256 or better (SHA-2 family) is now the standard</li>
      </ul>

      <h3>SHA-2 digital certificate</h3>
      <ul>
        <li>Most Common Today.</li>
        <li>SHA-2 family of hash functions includes - SHA-224, SHA-256 (most widely used), SHA-384, SHA-512</li>
      </ul>

      <h2>Working of PKI</h2>
      <ol>
        <li>You will generate a key-pair</li>
        <li>You will keep the private key secret</li>
        <li>
          Certificate Signing Request (CSR) is made for a domain name or multiple domain names. CSR includes your public
          key information and information about your domain inside a configuration file. CSR is then sent to CA. Below
          command generate key pair having password protected private key, and a CSR.

          <p>$ openssl req -newkey rsa:2048 -keyout crispinjacob.com.key -out crispinjacob.com.csr</p>
        </li>
        <li>
          CA verifies crispinjacob.com.csr and signs your public key and related information in the form of a signed
          public key certificate
        </li>
        <li>You will install your signed certificate in your server</li>
        <li>
          You will install your private key in your server. This private key is password protected while generating it.
          Only your server can use this private key.
        </li>
        <li>
          A webbrowwer or client application access your server and TLS handshake occures, and publick key certificate
          is downloaded to browser as part of HTTPS handshake
        </li>
        <li>
          Browser verifies the received server certificate before trusting it - validiyt, connected domain and domain
          name the certificate and so on.
        </li>
        <li>
          The certificate verification is baed on a trust achor that browser has access to. Trust anchor is a CA
          certificate that is often distribuited along with browser, or store in the OS that the browser trusts. Browser
          expects the downloaded server certificate is signed by this CA certificate (trust anchor)
        </li>
        <li>
          In most cases the server certificate is not signed by the root CA that comes with OS or brower. That will be
          another CA that the trust anchor CA trusts . This is called an intermediate CA. <br />
          In this case, the brower checks who signed the intermediate certificate. If it is signed by one of the trust
          Anchors then the brower trusts the downloaded server certificate. This verification is performed by decrypting
          that intermediate CA signature using trust anchors (root CA) public key.
        </li>

        <li>
          Often a further lower hierarchy CA might have signed the server certificate. <br />
          in this case, the brower verifies the issuer CA signed the server certificate, by decrypting server
          certificate signature with issuer CA public key. Then browser verifies the parent CA that signed the CA. This
          process goes from leaf node server certificate, up till trust anchror which is often the trust anchor
          certificate. If successful, at that point , the trust is established on the serer certificate. <br />
          Note that if you install one of the intermediate CA certificate in your brower/OS, then that will be your
          trust anchor, and you dont need to check till root CA. Often the entire chain of certificate is downloaded in
          single shot during TLS handshake. Note that if your browser misses one of the intermediate certificates, then
          your certificate's verification will fail.
        </li>
      </ol>

      <h3>Trust anchor</h3>
      <p>
        A trust anchor is the root certificate (or public key) that your system or application explicitly trusts. It’s
        the starting point for validating a chain of trust. If a certificate chain ends in a certificate that matches
        one of your trust anchors, the whole chain is considered trustworthy (as long as everything else checks out,
        like signatures and validity periods).
      </p>
      <p>
        An intermediate certificate can be a trust anchor, if you explicitly configure it as one. A trust anchor is
        stored in the system/browser/application’s trusted root CA store. But technically any certificate (including an
        intermediate) can be made a trust anchor if you configure it that way. When you do that, validation stops at
        that certificate, and no parent (like a root) is required. Let’s say you’re in a private network or using
        enterprise PKI, and you don’t want to trust a public root CA. Then you might trust a private intermediate CA as
        your trust anchor. This is valid — and often used in custom or constrained environments
      </p>
      <p>
        When a certificate is configured as a trust anchor, it's not validated like the rest of the chain. You’re
        telling the system: “I trust this cert — no questions asked.”
      </p>
      <h3>Certificate Chain</h3>
      <p>
        Server the entire certificate chain (except for the root certificate) is typically sent by the server during a
        TLS handshake. Certificate chain is based on chain of trust concept.
      </p>
      
      <figure>
        <img src="certificate_chain.gif" alt="802.1X components" width="550" height="400" />
        <figcaption>Certificate Chain(credit technospace.medium.com).</figcaption>
      </figure>
      
      <p>The certificate chain usually includes:</p>
      <ul>
        <li>Server certificate (e.g., www.example.com) – proves the identity of the server</li>
        <li>Intermediate certificate(s) – one or more certs that link the server cert to a trusted root</li>
        <li>
          Root certificate – usually not sent by the server, because It's already known and stored in the client's
          trusted root CA store (like in browsers or OS). It's assumed that clients already have a set of trusted root
          certificates installed. Sending it would just waste bandwidth
        </li>
      </ul>
      <p>
        When you view the certificate chain in a browser, sometimes you'll see the root certificate included in the
        chain. The browser didn’t get that root cert from the server during the TLS handshake. It pulled it from the
        local trust store and shows it in the chain for completeness. Browser is trying to display the full trust path,
        from the server cert all the way up to a trusted root. Even though the server didn’t send the root cert, the
        browser knows it's trusted (because it’s in the OS/browser trust store), so it includes it in the UI
      </p>
      <p>
        The sender decides the certificates includes in the certificate chain. For example sender may exclude
        unnecessary certificates, like trusted root certificate. It's considered a best practice to configure your
        webserver to deliver the full chain.
      </p>
      <p>
        If the certificate chain size exceeds TCP’s initial congestion window, it caan cause roundtrips to the TLS
        handshake. As newer TCP stack has initial congestion window increased to 10 TCP segments this is sufficient for
        most certificate chains.
      </p>
      <h3>Certificate validation</h3>
      <p>
        Many libraries (like OpenSSL, BoringSSL, Java's PKIXValidator, .NET, etc.) implement certificate validation
        according to RFC 5280, though behavior can slightly vary in edge cases (e.g., revocation policy, fallback
        logic).
      </p>

      <p>
        RFC 5280 is the gold standard for certificate validation rules in most of the internet. Key steps for
        certificate validation as defined in RFC
      </p>
      <ul>
        <li>Build a valid chain from the end-entity cert to a trusted anchor</li>
        <li>Verify each signature in the chain</li>
        <li>Check validity periods (notBefore / notAfter)</li>
        <li>Respect path length constraints (e.g., how many intermediates are allowed)</li>
        <li>Honor extensions (like whether a cert is allowed to sign other certs)</li>
        <li>Check for revocation (via CRLs or OCSP)</li>
        <li>Enforce name constraints and policies, if present</li>
      </ul>
      <p>In most real-world cases client validates the certificate chain during the TLS handshake</p>

      <p>Client should always validate the certificate, but it may not do that in some cases.</p>
      <ul>
        <li>
          Manually disabled validation (dangerous in production! Exposes you to MITM attacks) - Testing/local
          development, Self-signed certs without adding them to the trust store, Speed/complexity reasons (common in
          quick-and-dirty scripts)
        </li>
        <li>
          Custom validation logic - Some apps override the default logic. Accepting only certs signed by a specific
          intermediate, Performing extra checks (e.g., matching Common Name or SAN), Skipping revocation checks for
          speed
        </li>
        <li>
          Non-TLS protocols or legacy systems - Some old or proprietary protocols might use TLS but skip validation due
          to poor implementation
        </li>
      </ul>
      <p>
        Domain name verification is a critical part of certificate validation, especially for TLS/HTTPS. When a client
        connects to a server using HTTPS (like https://example.com), it must check that the server’s certificate is
        issued to that exact domain. This is called Hostname (or domain name) verification
      </p>
      <p>
        The client compares the requested domain name against: The Subject Alternative Name (SAN) field in the
        certificate, (Legacy fallback) The Common Name (CN) field in the Subject. This is defined in RFC 6125, and
        reinforced by TLS specs. Example: You go to https://mail.google.com . The server sends a cert with SANs like:
        DNS:*.google.com, this is valid. But if the cert only says DNS:api.example.com, then it is invalid for
        mail.google.com
      </p>
      <p>
        Verifying the domain name (hostname) is an essential part of certificate validation in HTTPS and other secure
        protocols. This validation is not part of the TLS protocol, but required by applications using TLS (like HTTPS,
        SMTP, etc.). TLS does not define how to match the certificate to the hostname. That’s left up to the application
        layer protocol.
      </p>
      <p>
        TLS itself implement certificate validation via the TLS libraries. not directly in the TLS protocol spec. The
        TLS protocol (e.g., TLS 1.2, TLS 1.3) defines that certificates are exchanged and must be validated. But it
        doesn't say how to do that validation in full detail. Instead TLS libraries (like OpenSSL, BoringSSL, GnuTLS,
        SChannel, etc.) are responsible for implementing Certificate parsing, Chain building, Signature verification,
        Extension checks (e.g., key usage, constraints), Revocation checking (optional). These libraries typically
        follow RFC 5280 for validation logic
      </p>

      <h3>Revoking a certificate</h3>
      <p>
        One method is to periodically download Certificate Revocation List (CRL) and inspect every certificate in the
        list. If the certificate is in revocation list , the certificate verification will be made to fail. This is not
        a scalable nechanism.
      </p>

      <p>
        The alternate mechanism is to use a protocol Online Certificate Status Protocol (OCSP).OCSP helps the client to
        check the validity of the certificate using a query instead of storing a list. The CA also need to support OCSP
        protocol.
      </p>

      <p>
        In OCSP Stapling protocol, the server retrieves OCSP response and sends to client during the handshake. As OCSP
        resonse is signed by CA, the client can verify it
      </p>
      <h3>SAN (Subject Alternative Name) and CN (Common Name)</h3>

      <p>
        The difference between SAN (Subject Alternative Name) and CN (Common Name) is a big deal in modern TLS/PKI. SAN
        is the modern, preferred way to specify valid hostnames. SAN supports multiple domains in one cert (multi-SAN or
        multi-domain certs). Modern browsers and TLS clients check SAN only. No SAN = invalid cert in most systems today
        (even if CN matches)
      </p>
      <p>
        Common Name (CN) is legacy way to specify the hostname. It was, originally used to identify the cert's primary
        domain. CN is deprecated (but still supported for compatibility)
      </p>

      <h3>CA:FALSE constraint in certificates</h3>

      <p>
        It means this certificate is not allowed to act as a Certificate Authority (CA). So it cannot issue other
        certificates — it's an end-entity certificate (also called a leaf certificate).
      </p>

      <ul>
        <li>CA certs → CA:TRUE - Can sign and issue other certificates</li>
        <li>
          End-entity certs (like websites) → CA:FALSE - Cannot sign or issue certs — they're at the bottom of the chain
        </li>
      </ul>

      <p>
        Assume an attacker gets access to an end-entity cert’s private key, the cert does not have CA:FALSE and
        validation client is misconfigured or vulnerable. The attacker can then use the stolen private key to Generate
        new bogus certificates for domains they don’t own like login.microsoft.com, and sign them using the compromised
        cert as the "issuer". Without CA:FALSE, the only thing preventing a cert from being a CA is... 'Hope'
      </p>
      <p>CA:FALSE is a critical defense-in-depth control.</p>

      <p>
        When validating a certificate chain, the TLS or PKI software will Reject any certificate in the chain (except
        the last one) that has CA:FALSE because intermediates must be CAs. Accept CA:FALSE only on the leaf
      </p>

      <p>
        . Think of it like marking a key "For Office Use Only" — it's not just about security, it’s about intent
        enforcement
      </p>

      <h3>CA creating a fake certificate and fake webserver</h3>
      <p>
        Often the rootCAs are and trusted. But when it comes to intermediates CAs of small size, there is a possibility
        of malicios actors. If your intermedicate CA issues a fake certificate using your domain name, you wont come to
        know about it. This certificate can be used for man in the middle attack since the brower will trust your domain
        name
      </p>
    </div>
  </body>
</html>