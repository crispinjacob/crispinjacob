<!doctype html>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
<link rel="stylesheet" type="text/css" href="../../styles/commonstyles.css" />
<link rel="stylesheet" href="../../styles/blogstyle.css" />
<link rel="stylesheet" href="../../styles/iconbarstyle.css" />

<html lang="en-us">
  <head>
    <title>TLS Explained</title>
  </head>

  <body>
    <div class="icon-bar">
      <a class="active" href="../../index.html"><i class="fa fa-home"></i></a>
    </div>

    <div style="padding: 20px">
      <h1>TLS Explained</h1>

      <p>16 March 2025</p>
      <hr />

      <!-- Basic concepts of encryption in cryptography -->

      <h2>TLS (Transport Layer Security)</h2>

      <p>
        TLS is a protocol that handles all practical aspects required for establishing a secure communication between
        two entities. TLS deprecates the older SSL (Secure Socket Layer) protocol . However the term SSL is still used
        by laymen to refer to TLS
      </p>
      <p>TLS Versions : TLS 1.0, TLS 1.1, TLS 1.2 , TLS 1.3</p>

      <p>
        TLS provides encryption, authentication and integrity (detect tampered messages with message authentication
        code)
      </p>

      <h3>TLS in HTTPS</h3>

      <p>
        TLS can be used with many application protocols to provide encryption and authentication using certificates . A
        common usecase is with HTTPS.
      </p>

      <p>HTTPS includes multiple protocols that works in tandem:</p>
      <ul>
        <li>1) TCP - Data transport</li>
        <li>2) TLS - Encryption, Digital certificates</li>
        <li>3) HTTP - Webpage exchange</li>
      </ul>

      <p>
        The process starts with TCP 3 way handshake (SYN, SYNC+ACK, ACK) to establish a TCP connection. This is often
        quick and happens within 60 to 70ms. Once the TCP connection between client and server is established , then TLS
        1.2 protocol kicks in which could take some 140 to 150ms:
      </p>

      <figure>
        <img src="03_TLS_12_full_handshake.png" alt="TLS 1.2 Handshake" width="400" height="500" />
        <figcaption>TLS 1.2 Handshake (Credit https://www.researchgate.net/).</figcaption>
      </figure>

      <ul>
        <li>
          Client &rarr; Server : Client Hello
          <ul>
            <li>Client Hello sends details of cipher suits supported by client</li>
            <li>Includes a random number called client random</li>
          </ul>
        </li>

        <li>
          Server &rarr; Client : Server Hello + Server Certificate + Server Key Exchange + Server Hello Done
          <ul>
            <li>Server sends information for calculating a symmetric key for communication encryption .</li>
            <li>
              Special case: Connection will terminate if server cannot find a supported ciphersuit in the list sent by
              client
            </li>

            <li>
              Sever Hello: includes details of cipher suit chosen by server and a random number called Server random
            </li>
            <li>
              Certificate Message: Server sends Server certificate to authenticate for the client to authenticate the
              server as it is signed by a trusted CA. Full server certificate chain including intermediate and leaf
              certificates are sent to client. Upon receipt, the client performs verifies the certificate. The steps
              include
              <ul>
                <li>1) Check digital signature of server certificate.</li>
                <li>2) Check expiry.</li>
                <li>3) certificate chain verification.</li>
                <li>4) Domain name check and so on.</li>
              </ul>
            </li>
            <li>
              Server Key Exchange: This optional message is used in some situations where additional data is required
              such as Diffie Hellman Key Exchange
            </li>
            <li>Server Hello Done: Server confirms it finished sending all its messages.</li>
          </ul>
        </li>

        <li>
          Client &rarr; Server : Client Key Exchange + Change CipherSpecs (CCS)
          <ul>
            <li>
              Client Key Exchange: The exchange depends on the key change method decided - for example in RSA client
              sends calculated premaster secret encrypted by server public key at this point . This helps server to
              calculate is session key. Upon receipt server decrypts the pre-master secret sent by client and calculate
              the session key.
            </li>
            <li>
              Change Cipher Spec: This tells server that client is ready to switch to encrypted mode as the client has
              generated the session key
            </li>
            <li>Finished: Indicate that client completed its handshake</li>
          </ul>
        </li>
        <li>
          Server &rarr; Client : Change CipherSpecs (CCS) + Finish
          <ul>
            <li>Change CipherSpecs: Server informs the client to switch to encrypted node</li>

            <li>Finish: This messages is encrypted with symmetric session key server generated</li>
          </ul>
        </li>
      </ul>
      <p>
        From this point onwards the session key (symmetric key) is used to encrypt all communication between server and
        client. So the server and client can now move on to use HTTP encrypted with session key (ie HTTPS)
      </p>
      <h2>TLS 1.3</h2>

      <p>
        TLS 1.2 message exchanges are inefficient at scale. TLS 1.3 protocol brings in several enhancements to TLS 1.2 .
        One important improvement in TLS 1.3 is the number of roundtrips required for handshake is reduced from two in
        to one.
      </p>
      <ul>
        <li>
          TLS 1.2 Roundtrip 1:
          <ul>
            <li>To sever: (Client Hello)</li>
            <li>To client (Server Hello + Server Certificate + Server Key</li>
            Exchange + Server Hello Done)
          </ul>
        </li>
        <li>
          TLS 1.2 Roundtrip 2:
          <ul>
            <li>To Server: (Client Key Exchange + Change CipherSpecs)</li>
            <li>To Client : (Server Finished)</li>
          </ul>
        </li>
        <li>
          TLS 1.3 Roundtrip 1:
          <ul>
            <li>To Server : (Client hello)</li>
            <li>To client : (Server Hello + ...)</li>
          </ul>
        </li>

        <li>
          TLS 1.3 Half roundtrip:
          <ul>
            <li>To Client : Finished</li>
          </ul>
        </li>
      </ul>

      <p>
        Another improvement is the removal of RSA which was computationally very heavy. It introduces ECDH
        (ECC/Diffie-Hellman) as a replacement for RSA. This is lighter in computation as compared to RSA.
      </p>

      <p>
        TLS 1.3 operates in 1 RTT mode most of the time where the handshake is complete in 1 round trip. This is
        different from TLS 1.2 which needed 2 round trip.
      </p>

      <p>
        TLS 1.3 supports both 1 RTT and a new Zero Round Trip Resumption (0 RTT) mechanism added in. Over all RTT is
        reduced by storing some of the session parameters in server avoiding the need of a round trip when the client
        connect to server second time onwards. On the negative side it reduces forward secrecy by allowing to decrypt
        older messages using same session key used in a later sessoin. This is not easy to achieve though.
      </p>

      <p>
        TLS 1.3 also cut short the number of cipher suits supported from a larger number supported in TLS 1.2. The
        smaller list is faster to exchange.
      </p>
      <p>
        TLS 1.2 messages are tamper protected with Message Authentication Code (MAC). But TLS 1.3 usese digital
        signatures to secure messages from the beginning
      </p>

      <h2>TLS Record Protocol</h2>
      <p>TLS uses two sub protocols:</p>
      <h3>1. Handshake Protocol</h3>
      <p>Handshake protocol is responsible for authentication, key exchange, and negotiation of security parameters.</p>

      <p>
        RSA Handshake- client generates a symmetric key and then the client encrypts it with the serverâ€™s public key and
        shares across. RSA is getting obsolete since if the private key is leaked out, all older messages can be
        decrypted.
      </p>
      <p>
        Diffie-Hellman handshake - Client and Server derives the key without sending it through communication channel.
        So leaking private key cannot be used to retrive previous communication and thus maintains forward secrecy.
      </p>

      <h3>2. Record Protocol</h3>
      <p>
        Record protocol is responsible for encryption application data using symmetric key generated with Handshake
        protocol. Message Integrity Checks are performed on each record to make sure that data is not tampered.
      </p>

      <p>Record size:</p>

      <p>
        Appliction data is transmitted in record protocol and the maximum allowed size is 16 KB. Record header may take
        between 20 to 40 bytes on top of TCP header requirements. Framing overhead reduces as the record size grows. But
        if the lager record is split into multiple TCP packets, there will be more wait time for packets to arrive
        contributing to larger latency. It is possible to configure the maximum record size to use
      </p>

      <h2>TLS Session Resumption</h2>
      <p>
        TLS session has a session identifier which is sent as part of Server Hello message. Using session ID, the client
        can re-use the session parameters. This helps to reduce the handshake messages next time, by reusing previous
        session parameters.
      </p>

      <h2>Cipher Suits</h2>
      <p>
        Let us take an example of a cipher suite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256. Below given is the breakup:
      </p>
      <ul>
        <li>TLS - Protocol used.</li>
        <li>ECDHE - Key exchange algorithm used for the session - Elliptic Curve Diffie-Hellman Ephemeral</li>
        <li>
          ECDSA - Authentication algorithm used. Elliptic Curve Digital Signature Algorithm. The server's certificate is
          signed using ECDSA (instead of RSA)
        </li>
        <li>WITH_AES_128_GCM - Symmetric encryption: AES with with a 128-bit key in GCM mode</li>
        <li>SHA256 - Hash function used in the TLS PRF (Pseudo Random Function) and for handshake message integrity</li>
      </ul>
      <h2>References</h2>
      <ul>
        <li>
          https://crypto.stackexchange.com/questions/93641/can-we-pick-which-key-is-private-or-public-in-asymmetric-encryption-do-the-keys
        </li>
        <li>https://docs.openssl.org/1.1.1/man1/ciphers/#tls-v12-cipher-suites</li>
      </ul>
    </div>
  </body>
</html>